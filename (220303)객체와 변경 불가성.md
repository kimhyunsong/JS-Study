

# 객체와 변경불가성

Immutability는 객체가 생성된 이후 그 상태를 변경할 수 없는 디자인 패턴을 말한다.
Immutability는 함수형 프로그래밍의 핵심 원리이다



객체는 참조 형태로 전달 받고 전달하는데, 이것이 공유되어있다면 문제가 되므로, 
참조를 가지고 있는 다른 장소에 변경 사실을 통지하고 대처하는 추가적인 대응이 필요하다
따라서 이를 위해 객체를 불변객체로 만들어, 객체의 변경이 필요한 경우 방어적 복사(defensive copy)를 통해 새로운 객체를 생성한 후 변경한다.
또는 Observer 패턴으로 객체의 변경에 대처할 수 있다.



- 옵저버 패턴 : 객체의 상태 변화를 관찰하는 관찰자들, 즉 옵저버들의 목록을 객체에 등록하여 상태 변화가 있을 때마다 메서드를 통해 객체가 직접 목록의 각 옵저버에게 통지하도록 하는 디자인 패턴을 말함
- 옵저버 또는 리스너라 불리는 하나 이상의 객체를 관찰 대상이 되는 객체에 등록시킨 후 옵저버들은 관찰 대상인 객체가 발생하는 이벤트를 받아 처리한다.
구현
https://blog.naver.com/PostView.nhn?isHttpsRedirect=true&blogId=c_ist82&logNo=220795909036

ES6 에서는 불변 데이터 패턴을 쉽게 구현할 수 있는 새로운 기능이 추가됨.

```js
var str = 'Hello'; str = 'world';
```

위 예제 코드에서는 Hello가 world로 변경되는 것이 아닌, Hello와 world가 메모리에 모두 존재하고 있지만 메모리 주소를 가리키는 것이 변경되었을 뿐이다
따라서 slice 메서드 역시 새로운 문자열을 생성해서 return 한다

한편 다음 예제는 mutable 한 값인 객체 메서드에 대한 예제이다

```js
var arr = []; console.log(arr.length)  var v2 = arr.push(2) console.log(arr.length) //1 
```





push()는 직접 대상 배열을 변경하기 때문에 arr값이 업데이트 되었음을 알 수 있다.

객체의 프로퍼티가 immutable일 경우 다른 변수에 할당 후 변경해도 원래의 객체의 프로퍼티 값은 변하지 않지만
객체 자체를 다른 변수에 할당할 경우 변수를 변경하였을 때 원래의 객체도 변경된다.
이는 원래의 객체와 변수에 할당한 객체가 같은 주소를 참조하기 때문이다

따라서 이와같은 원리에 의해 앞서 설명한 불변 데이터 패턴이 필요하다







불변 데이터 패턴(ES6)
: 객체의 방어적 복사를 통해 새로운 객체를 생성한 후 변경한다.


- 객체의 방어적 복사
Object.assign : 타깃 객체로 소스 객체의 프로퍼티를 복사한다. 리턴값으로 타깃 객체를 반환한다.
: shallow copy
: 빈 객체에 copy하기 위해 assign의 첫번째 인자로 빈객체를 받아온다.

```js
var temp = {
	name : 'kim',
	age : 58,
    temp45 : {
        asd :123
    }
}
//merge
var temp2 = Object.assign({14, 5}, temp)
var temp3 = Object.assign({}, {14, 5}, temp)
```



- 불변 객체화를 통한 객체 변경 방지
  Object.freeze 

  ```
  temp.name = 'lee' //무시됨.
  ```

  

- 변경하려는 코드가 있을 경우 무시된다
하지만 객체 내부의 객체는 변경 가능하다.
객체 내부까지 변경 불가능하게 만드려면 Deep freeze를 사용한다
: forEach나 of 를 사용하여 모든 객체의 프로퍼티를 freeze 시킨다.
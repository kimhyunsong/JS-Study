# 220321

## 클래스 2

#### private 필드 정의 제안

자바스크립트는 캡슐화를 완벽하게 지원하지 않음.

(Public, private, protected)접근 제한자를 제공 하지 않기 때문

따라서 모든 자바스크립트 객체의 프로퍼티와 메서드는 기본적으로 public하다



클래스 필드 정의 제안을 사용하더라도 클래스 필드는 기본적으로 public하기 때문에 외부에 그대로 노출된다.

```js
class Person {
	name = 'kim'
}
const me = new Person();
console.log(me.name)
```



현재는(2021년 1월 이후?)  private필드를 정의할 수 있다.

private 필드의 선두에는 **#**을 붙여준다.

```js
class Person {
    
	#name = '';
    
	constructor(name) {
		this.#name = name;
    }
}
const me = new Person('Kim')
console.log(me.#name); // error
```



> 접근제한자(public, private, protected)를 모두 지원하는 것이 TypeScript이다



 클래스 외부에서 private 필드에 직접 접근할 수는 없지만 접근자 프로퍼티를 통해 간접적으로 접근할 수 있다.

```js
class Person {
    #name = '';
    constructor(name) {
        this.#name = name
    }
    get name() {
        return this.#name.trim();//공백제거
    }
    
}
const me = new Person('   kim   ');
console.log(me.name);
```



private 필드는 반드시 클래스 몸체에서 정의해야 하며, constructor에 직접 정의하면 에러가 발생한다.



#### static 필드 정의 제안

(Private 필드와 마찬가지로 static 필드를 정의하는 새로운 방안의 제안이다)

> https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Classes/static
>
> static 키워드 == 클래스의 정적 메서드를 정의함
>
> 1. 정적 메서드 클래스에 속한 함수를 구현하기 위해 사용한다.
> 2. 메서드를 프로퍼티 형태로 직접 할당하는 것과 동일한 기능을 한다.
>
> https://ko.javascript.info/static-properties-methods

```js
class MyMath {
    //static public 필드 정의
    static PI = 22/7;
    //static private 필드 정의
    static #num = 10;
	//static 메서드
	static increment() {
        console.log(this.#num)
        return ++MyMath.#num; //(++this.#num) 도 가능하다.
    }
}
//생성자 없이 그냥호출함
console.log(MyMath.PI);
console.log(MyMath.increment());
```



### 상속에 의한 클래스 확장

#### 클래스 상속과 생성자 함수 상속

- 상속에 의한 클래스 확장은 프로토타입 기반 상속과는 다르다.
- 프로토타입 기반 상속은 프로토타입 체인을 통해 다른 객체의 자산을 상속받는 개념이지만,
- 상속에 의한 클래스 확장은 기존 클래스를 상속받아 새로운 클래스를 확장하여 정의하는 것이다.
- (내 생각 : 프로토타입은 참조형태(스코프형태로 이어짐), 클래스상속은 가져와서 내거로 만듦)

```js
class Animal {
    constructor(age, weight) {
        this.age = age;
        this.weight = weight;
    }
    eat() {return 'eat';}
    move(){return 'move';}  
}

class Bird extends Animal {
    fly() {return 'fly';}
}
const bird = new Bird(1, 5);
console.log(bird);
console.log(bird instanceof Animal);
console.log(bird.eat());
console.log(bird.age);
```

클래스는 상속을 통해 다른 클래스를 확장할 수 있는 문법인 extends 키워드가 기본적으로 제공된다.





#### 동적 상속

extends 키워드는 클래스뿐만 아니라 생성자 함수를 상속받아 클래스를 확장할 수도 있다. 단, extends 키워드 앞에는 반드시 클래스가 와야한다.



```js
function Base(a) {
	this.a = a;
}
// 생성자 함수를 상속받는 서브클래스
class Derived extends Base{}
const derived = new Derived(1)
console.log(derived.a)
```



extends 키워드 다음에는 클래스뿐만 아니라 [[Construct]] 내부 메서드를 갖는 함수 객체로 평가될 수 있는 모든 표현식을 사용할 수 있다. 이를 통해 동적으로 상속받을 대상을 결정할 수 있다.

```js
function Base1(){}
class Base2{}
let condition = true;
class Derived extends (condition ? Base1 : Base2){}
```



#### 서브클래스의 constructor

args는 new 연산자와 함께 클래스를 호출할 때 전달한 인수의 리스트이다.

```js
constructor(...args) {super(...args)}
//super()는 수퍼클래스의 constructor(super-constructor)를 호출하여 인스턴스를 생성한다.
```



#### super 키워드

super 키워드는 함수처럼 호출할 수도 있고 this와 같이 식별자처럼 참조할 수 있는 특수한 키워드이다.

```js
class Base {
    constructor(a, b){
	    this.a = a;
    	this.b = b
    }
}
class Derived extends Base {
    // constructor가 없을 경우 암묵적으로 constructor가 정의된다.
    // constructor(...args) {super(...args)}
}
const derived = new Derived(1, 2);
console.log(derived)
```

하지만 수퍼클래스의 constructor에 인수를 전달할 필요가 있는 경우 서브클래스의 constructor는 생략할 수 없다.



```js
class Base {
    constructor(a, b){
        this.a =a 
        this.b= b
    }
}
class Derived extends Base {
    constructor(a, b, c) {
        super(a, b)
        this.c = c
    }
}
const derived = new Derived(1, 2, 3)

```



super를 호출할 때 주의할 사항

1. 서브 클래스에서 constructor를 생략하지 않은 경우, 반드시 super를 호출해야한다.
2. 서브 클래스의 constructor에서 super를 호출하기 전까지는 this를 참조할 수 없다.
3. super는 반드시 서브클래스의 constructor에서만 호출된다. 서브클래스가 아닌경우 에러가 발생



super 참조

1. 서브클래스의 프로토타입 메서드 내에서 super.sayHi는 수퍼클래스의 프로토타입 메서드이다.

```js
class Base {
	constructor(name) {
        this.name = name
    }
    sayHi() {
        return console.log(`hi ${this.name}`)
    }
}
//서브클래스
class Derived extends Base {
    sayHi(){
        return `${super.sayHi()}`
    }
}
const derived = new Derived('kim');
console.log(derived.sayHi())
```



458부터


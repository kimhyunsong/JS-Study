# 220315

## 클래스

### - 클래스는 프로토 타입의 문법적 설탕인가?

문법적 설탕(Syntax Sugar) :   읽는 사람 또는 작성하는 사람이 편하게 디자인 된 문법

프로토타입 객체 지향 언어 === 클래스가 필요 없는 객체지향 프로그래밍 언어





#### ES5 문법에서 클래스 없이 만든 객체 지향 언어의 상속 구현

```js
var Person = (function(){
    // 생성자 함수
    function Person(name){
        this.name =name;
    }
    //프로토타입 메서드 생성
    Person.prototype.sayHi = function(){
        console.log('Hi! My name is' + this.name)
    }
    
	return Person
}())
//생성자 함수를 통해 인스턴스 생성(me)
var me = new Person('Lee')
me.sayHi(); // Hi! My name is Lee
```



#### ES6 부터는 클래스를 도입

차이점 : 클래스와 생성자 함수는 모두 프로토타입 기반의 인스턴스를 생성하지만 정확히 동일하게 동작하지 않음 -> 생성자 함수보다 엄격하며 생성자 함수에서 제공하지 않는 몇몇 기능이 있음

> 1. 클래스를 new 연산자 없이 호출하면 에러가 발생한다. 하지만 생성자 함수를 new 연산자 없이 호출하면 일반함수로 호출이 가능
> 2. 클래스는 상속을 지원하는 extends 와 super 키워드를 제공한다. (생성자 함수X)
> 3. 클래스는 호이스팅이 발생하지 않는 것처럼 동작한다(?)
> 4. 클래스 내의 모든 코드는 Strict mode가 암묵적으로 지정되어 해제할 수 없다.
> 5. 클래스의 constructor, 프로토타입 메서드, 정적 메서드는 모두 프로퍼티 어트리뷰트[[Enumerable]]값이 false다(열거되지 않는다.)

> Object.prototype.propertyIsEnumerable()이라는 빌트인 메서드가 있는데
>
> 요약하자면 이 메서드는 지정된 속성이 열거 가능하고, 개체 자체의 속성인지 여부를 나타냄
>
> ```js
> const object1 = {};//객체
> const array1 = [];//배열
> object1.property1 = 42;//프로퍼티 추가
> array1[0] = 42;//배열 값 추가
> 
> console.log(object1.propertyIsEnumerable('property1'));
> // expected output: true
> 
> console.log(array1.propertyIsEnumerable(0));
> // expected output: true
> 
> console.log(array1.propertyIsEnumerable('length'));
> //length 는 Object의 메서드임
> // expected output: false
> ```
>
> 
>
> https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/propertyIsEnumerable





### 클래스 정의 

일반적으로 파스칼 케이스를 사용하는 것을 권장

```js
class Person{}
```

함수와 유사하게 표현식으로 정의도 가능하고 익명 클래스를 사용할 수도 있다.

```js
const Person = class{}
const Person = class MyClass {}
```



**클래스를 표현식으로 정의할 수 있다는 것은 클래스가 ''값''으로 사용할 수 있다는 것이다. (클래스 === 일급 객체**)

- 무명의 리터럴로 생성할 수 있다.(즉 런타임에 생성이 가능하다)
- 변수나 자료구조(객체, 배열)에 저장할 수 있다
- 함수의 매개변수로 전달할 수 있다.
- 함수의 return 값으로 사용할 수 있다.





클래스의 메서드



클래스에는 메서드만 정의가 가능하다.

정의할 수 있는 메서드 

1. 생성자(constructor)
2. 프로토타입
3. 정적 메서드

```js
class Person {
	constructor(name){
        //인스턴스 생성 및 초기화
        this.name = name
    }
    //프로토타입 메서드
    sayHi(){
        console.log(`Hi! My name is ${this.name}`);
    }
    //정적 메서드
    static sayHello(){
        console.log('Hello')
    }
   
}
//인스턴스를 생성
const me = new Person('Lee')
//인스턴스의 프로퍼티 참조
console.log(me.name)
//프로토타입 메서드 호출
me.sayHi();
//정적 메서드 호출
Person.sayHello();
```



#### 클래스 호이스팅

클래스 선언문으로 정의한 클래스는 함수 선언문처럼 소스코드 평가 과정, 즉 런타임 이전에 먼저 평가되어 함수 객체를 생성한다. 이때 클래스가 평가되어 생성된 함수 객체는 생성자 함수로서 호출할 수 있는 함수로서 호출할 수 있는 함수 즉 constructor이다. 이 시점에 프로토타입도 더불어 생성된다. 

프로토타입과 생성자 함수는 항상 쌍으로 존재하기 때문이다.

하지만 클래스는 클래스 정의 이전에 참조할 수 없다.

```js
console.log(Person);
class Person{}

//위의 예제를 출력하면 cannot access before initialization이라는 오류가 출력된다.
//아직 선언(실행 컨텍스트 생성 이전 코드 평가) 이후에 초기화(실행 컨텍스트 이후)가 안되었다는 뜻이다.
```

![image-20220315200733340](C:\Users\ssong\Desktop\JS\image-20220315200733340.png)

그렇다고 호이스팅이 발생하지 않은 것은 아니다.

```js

const Person = '';
{
    // 호이스팅이 발생하지 않는다면 아래 log는 ''가 찍혀야 정상이다. (함수 블록이 아님 === 스코프가 전역 스코프에 바인딩되어있음)
    console.log(Person) // cannot access 'Person' before initialization
    //클래스 선언문
    class Person{}
}

```

위 예시 코드르 보았을 때 클래스 호이스팅은 분명히 발생하는 것을 알 수 있다.

**단, 클래스는 let, const 키워드로 선언한 변수처럼 호이스팅된다.(=== 선언과 초기화가 동시에 일어나지 않는다.)**

따라서 클래스 선언문 이전에 일시적 사각지대(TDZ)에 빠지기 때문에 호이스팅이 발생하지 않는 것처럼 동작한다.

### 인스턴스 생성

클래스는 생성자 함수이며 반드시 new 연산자와 함께 호출되어 인스턴스를 생성한다.

```js
class Person{}
const me = new Person();
console.log(me); Person{}
```

그냥 new 없이 쓰면 에러가 발생한다

```js
class Person{}
const me = Person();
TypeError : Class constructor Foo cannot be invoked without 'new'
```



